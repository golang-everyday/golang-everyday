# 八百字理解 go 指针

> 这篇文章写给那些不太熟悉 go 指针的 gopher

## 什么是指针？

简单来说， 指针变量存储一个内存地址值，其值指向另一个内存地址。这是官方定义， 但是如果你以前用的语言并不涉及到指针操作，那么这个定义对你来说就是用象形文字写的。



我们来翻译一下。



## 内存是什么？

计算机内存，简写 RAM， 可以想象成是 一系列的盒子，一个盒子挨着一个盒子排成一串。每个盒子，都有自己的独一无二的标签（编号），该编号按顺序递增。 这个编号就是内存盒子的地址，或者叫做 单元格的地址。

![memory.png](https://i.loli.net/2019/05/17/5cde6ac7346ab72202.png)

每一个单元格里都包含一个值。如果你知道单元格的地址（202），你就可以到该单元格读取其中的值（a），或者对该值进行修改(a=>b)或者替换为任何你想要存储的值。[译者注 - 简而言之：知道内存的单元格地址，你就可以对该单元格 为所欲为。]



以上就是关于内存的表面知识。CPU所做的一切运算，都是从内存中取值计算，或写入内存。



## 什么是变量？

要编写一个程序，读取内存地址为 200 的单元格内的值， 并将其 乘以 3 ，并放入到 201 的单元格中，伪代码表示如下：

* 读取 单元格 200 内的值，并放入 CPU 中
* 由 CPU 将该值 乘以 3
* 将 计算结果 存入 201 单元格

![cpu_plus_3.png](https://i.loli.net/2019/05/17/5cde6f309d55d18734.png)

这正是古老程序的编写方式，coder 会保留一个内存地址列表，标示出 使用它的人，时间以及存储在内存里面的值。



很显然 这么做 无聊且容易出错，而且程序构造期间，要为所有可能使用的值分配一个内存地址，且存入内存。还有更坏的：这种机制使得程序在运行时候需要动态地为变了分配存储 - 约等于你只能使用全局变量来编写大型程序。



为了解决以上问题， 创造了一个变量的概念。变量就是内存位置的一个别名。



现在，我们介绍了变量，那就讨论下变量（内存地址的别名）。

上面那个程序，使用变量就可以表示为：

* 读取变量 a 的值并写入 CPU

* CPU 运算 值x3

* 写入结果到 变量 b 中

  ![Unti<x>tled-1-300x203.png](https://i.loli.net/2019/05/17/5cde72d6d460e90892.png)

这是两个程序是一样的，只不过第二个版本做了重大改进 -> 使用变量代替内存地址，我们不需要再对内存地址进行追踪维护 - 编译器会为我们解决这个问题。



现在这个程序可以这么写：

```go
a := 6
b := a * 3
```

编译器会确保变量a,b有且有唯一的内存地址，用来保存他们对应的值。



## 什么是指针？

现在我们知道内存就是一系列的有序单元格组合，变量就是单元格地址的别名（由编译器指定），那么什么是指针呢？



指针是一个值，该值存储的是 另外一个值的内存地址。



指针指向一个变量的内存地址，如同该变量表示的内存地址一样。



看下这段代码：

```go
func main() {
    a := 200
    b := &a
    *b++
    fmt.Println(a) // 201
}
```

在第一行我们声明了一个变量 a , 并赋值为 200 。

![a.png](https://i.loli.net/2019/05/17/5cde7a1a1ad6b46753.png)

接下来，我们声明了一个变量 b, 并将 a 的内存地址 作为值 赋给了 b。（&a 即为取a的内存地址）

![b.png](https://i.loli.net/2019/05/17/5cde7a366346847019.png)

记住： 我们并不知道 a 的具体内存地址，但我们依旧可以将 a 的内存地址 给 b 存储。



`    *b++`  第三行最绕，因为 go 语言是强类型语言。变量 b 保存了 a 的内存地址，但我们想要 a 里面保存的值进行 ++ 操作。为了实现 ++ 操作，我们需要 解引用 b， 根据 b 保存的内存地址来找到 a 。

![a-b.png](https://i.loli.net/2019/05/17/5cde7abf2cdcb84888.png)



找到 a 后我们 进行 ++ 操作，并存储在 b 所指定的 内存地址（即a的地址）中。

![2019-05-17_17-14.png](https://i.loli.net/2019/05/17/5cde7b827fb9633065.png)

最后打印 a 的值， 输出 应为 201 。



## 小结

如果你从别的没有指针的语言转到go，或者每个变量的指针都是隐含的，不必惊慌，多写多练就能掌握指针了。

记住这条规则：

***指针是指向另一个变量的内存地址的值。***



> 译文
>
> 原文地址： <https://dave.cheney.net/2017/04/26/understand-go-pointers-in-less-than-800-words-or-your-money-back>
>
> 译者： zcqzcg
>
> 如有错误之处，还请多多斧正。
